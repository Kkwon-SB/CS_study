# 자료 구조

데이터를 어떤 식으로 저장하고 관리할 것인지를 말한다. 보통 알고리즘의 흐름에 따라서 데이터를 어떻게 저장할지 결정한다. 대표적인 자료구조는 스택 큐 배열 링크드리스트 트리 등이 있다.

## 예상 질문

### 스택 vs 큐

* Q. 자료 저장 형태 중 스택과 큐에 대해서 설명하시오
* Q. 스택과 큐는 어떤 차이가 있나요
* Q. 스택과 큐를 적용할만한 예를 들어 설명해주세요

**FILO FIFO**

스택 : 
쌓여있다는 의미, 책이 책상위에 쌓여있고 제일 위에 있는 책 부터 꺼내는 방식이 스택, 
나중에 입력한 데이터 부터 먼저 꺼낼 수 있어서 FILO 라고 한다.

큐 : 
줄을 서는 개념과 유사, 먼저 줄을 서는 사람이 먼저 나간다. 먼저 들어갔던 데이터를 먼저 꺼내어 사용한다.
FIFO라고 한다.

### 배열 vs 링크드 리스트

* Q. 배열과 링크드 리스트에 대한 차이점을 설명하세요
* Q. 배열과 링크드 리스트의 장단점을 기반으로 활용하면 더 좋은 예제를 말하시오.
* Q. 이진 트리 자료 구조를 배열로 구현하는 방법에 대해서 말하시오
**정적할당, 동적할당, 연속 저장, 비연속 저장**

배열 : 정적할당, 연속저장<br>
배열은 옆으로 나란히 있는 모습을 말한다. 배열은 메모리의 어느 위치에 한 개씩 저장되는 연속. 메모리의 연속된 저장공간에 저장된다. <br>
숫자 저장, 순서의 의미를 가지는 데이터 활용 시, 평균을 낼 수도 있다.<br>
단점 - 미리 저장공간을 할당 받아서 사용한다. 사용하지 않는 공간이 생길 경우 낭비되는 단점, (조금씩 늘리는 방법은 비효율적-재선언 후 옮겨야 하기 때문)<br>
데이터 삭제 or 중간 위치에 값을 넣을 경우 값을 옮겨주어야 하기 때문에 번거롭다는 문제(프로그램 복잡도 높아짐)<br>
 
링크드 리스트 : 동적할당, 비연속 저장<br>
배열과 유사하지만 저장 방식이 다르다. 서로의 위치를 포인터로 가지고 있고, 필요한 만큼 저장 공간을 할당 받기 때문에 사용량을 처음부터 설정할 필요 없다.(유연한 형태-확장이 용이) 배열에 비해 중간에 데이터 추가 삭제 과정이 간편하다. <br>
ex) 입력될 데이터의 양이 변동적일 때, 유용<br>
단점 - 배열에 비해 느린속도를 가진다. 그 이유는 링크드 리스트의 포인터에 저장된 다음 값의 위치를 찾아가야 하기 때문이다. 시간 복잡도 상의 지연이 아닌, 메모리 상에서 인접하지 않은 위치의 데이터를 가져오면서 발생하는 물리적인 속도 문제이다.  배열과 달리 임의 접근이 불가능하다.
<br>
=>파이썬은 리스트 타입이 링크드 리스트의 기능을 모두 지원한다.<br>

### 트리 구조

* Q. 자료 구조 형태 중 트리 구조에 대해서 설명하시오
* Q. 왜 트리구조를 사용하나요?
* Q. 트리 구조의 활용 사례

**이진트리,노드,부모노드,자식노드,O(Log(N))**

트리는 나무와 같은 형태로 데이터를 저장하는 자료구조의 일종이다. 부모와 자식 노드들로 이루어져 있고, 자식이 아래에 위치한다.<br>
특정 기준에 따라 부모 노드의 오른쪽 또는 왼쪽에 자식 노드가 연결된다.<br>
자식의 수는 트리의 형태마다 차이가 있는데, 이진트리의 경우 2개의 자식 노드로 구성된 트리를 의미한다.(자식의 수를 차수라고 함)<br>
배열이나 링크드리스트로 구현 가능, <br>
트리의 노드들이 인덱스가 있거나 정렬되어 있는 데이터인 경우 풀스캔을 하지 않아도 되는 장점이 있다. 시간 복잡도를 O(Log(N))을 가진다.(속도가 빠름)


# 알고리즘
어떤 문제를 해결하기 위한 단계적인 절차나 방법을 의미합니다.

### 정렬

* Q. 정렬 방식 중 알고 있는 방식을 말하시오 
* Q. 정렬 방식의 종류 중에서 가장 효율적인 정렬 방식은 무엇입니까?
* Q. 퀵 정렬이란? 어떤 장단점 및 특징이 있나요?

**퀵 정렬, 버블 정렬, 선택 정렬, 삽입 정렬, 병합(합병) 정렬, 시간 복잡도**

선택 정렬 : (Selection Sort)
선택정렬은 앞에서부터 차례대로 정렬하는 방법입니다. 먼저 주어진 리스트 중에 최소값을 찾고 그 값을 맨 앞에 위치한 값과 교체하는 방식으로 진행하는 정렬방법입니다.
정렬을 위한 비교 횟수는 많으나 교환 횟수는 상당히 적다는 것이 장점인 정렬 방식입니다. 따라서 교환이 많이 이루어져야하는 자료 상태에서 가장 효율적으로 적용될 수 있는 정렬 방식입니다. 선택 정렬이 가장 적합한 자료 상태는 역순 정렬입니다. 즉, 내림차순으로 정렬되어 있는 자료를 오름차순으로 재정렬할 때 최적의 효율을 보여줍니다. 반대로 이미 정렬된 상태에서 소수의 자료가 추가됨으로 재정렬하게 되는 때에는 최악의 처리 속도를 보여준다는 단점도 있습니다.
n개의 원소에 대하여 n개의 메모리를 사용합니다. 

버블 정렬 : (Bubble Sort)
버블정렬은 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 끝부터 정렬하는 방식을 말합니다.
데이터를 하나씩 비교할 수 있어서 정밀하게 비교가 가능하나 비교횟수가 많아지므로 성능면에서는 좋은 방법이 아닙니다. 첫 번째 원소부터 마지막 원소까지 반복하여 한 단계가 끝나면 가장 큰 원소를 마지막 자리로 정렬하는 식으로 정렬이 됩니다. 
n개의 원소에 대하여 n개의 메모리를 사용합니다. 

병합 정렬 : (Merge Sort)
작은 단위로 잘게 쪼개어 작은 단위부터 정렬해서 정렬된 단위들을 계속 병합해가면서 정렬하는 방식입니다. 알고리즘 중에 가장 간단하고 쉽게 떠올릴 수 있는 방법이며 안정성이 있여 상당히 좋은 성능을 나타냅니다. 하나 큰 결점이 있다면 공간이 많이 필요하다는 점입니다. 정렬을 하기 위해서는 데이터 전체 크기만한 메모리가 더 필요합니다.

퀵 정렬 : (Quick Sort)
연속적인 분할에 의한 정렬방식입니다. 처음 하나의 축(Pivot)을 먼저 정하여 이 축의 값보다 작은 값은 왼쪽에 큰 값은 오른쪽으로 위치시킨뒤 왼쪽과 오른쪽의 수 들은 다시 각각의 축으로 나누어져 축값이 1이 될 때까지 정렬합니다. 가장 많이 사용되는 정렬법이나 안정성이 떨어진다는 단점이 있습니다. 

힙정렬 : (Heap Sort)
힙 정렬은 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법입니다. 이진 완전 나무를 배열에다 접목시킨 절묘한 알고리즘입니다. 처음에는 나무 아래에서 위로 각 원소들을 최대값 힙 조건에 맞게 정리한 뒤, 나무 뿌리에 있는 자료를 차례차례 나무 뒤로 옮기면서 힙을 정렬된 배열로 바꿉니다. 뿌리에는 힙 나무 맨 뒤에 있던 원소가 왔다가, 다시 힙 조건에 맞는 위치로 내려갑니다. 시간복잡도가 O(nlogn)인 정렬 알고리즘 중에서는 부가적인 메모리가 전혀 필요없다는 게 큰 장점인 정렬 방식입니다.

쉘 정렬 : (Shell Sort)
삽입정렬의 개념을 확대하여 일반화한 정렬방법입니다. 알고리즘이 간단하여 프로그램으로 쉽게 구현할 수 있습니다. 수행 능력도 삽입 정렬보다 우수한 것으로 평가합니다. 멀리 있는 레코드들끼리 비교 및 교환될 수 있으므로, 어떤 데이터가 제 위치에서 멀리 떨어져 있다면 여러 번의 교환이 발생하는 버블정렬 방식의 단점을 해결할 수 있습니다.

기수 정렬 : (Radix Sort)
데이터의 비교를 통한 정렬이 아닌 분산 정렬을 이용한 정렬 방법이며 자릿수가 있는 데이터(정수, 문자열 등)에만 사용 가능합니다. 각 자리수를 기준으로 점차 정렬을 진행합니다.


![image](https://user-images.githubusercontent.com/76522430/214115505-1e4cbbf8-a24c-447f-8d24-e5606c088033.png)

![image](https://user-images.githubusercontent.com/76522430/214115537-6686e020-70a1-4b69-99d9-f00dbf569d82.png)

![image](https://user-images.githubusercontent.com/76522430/214116743-d25b0b64-e9bf-438d-a5de-76ac3f5ebb92.png)




* Q. 
* Q. 
* Q. 
* Q. 
* Q. 
* Q. 
* Q. 
* Q. 
* Q. 
